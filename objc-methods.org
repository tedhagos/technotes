#+title: Methods
#+index: objc!methods


Methods can be defined either as belonging to the class or scoped to the instance of the class (the object). Unlike Java or C#, where you write a method the way you would write a function, that is not the case in Objective  C. Methods are written distinctly different than regular functions. 

* Static and Instance Methods

An instance method, that is a method scoped to the object rather it's class, is written with a minus sign in the beginning. A method scoped to the class (a static method) is written out with a plus sign instead 

  #+begin_example

  @interface Person : NSObject 
    -(void talk);
  @end

  @implementation Person
    -(void) talk {
      NSLog(@"Person talking");
    }
  @end

  int main() {
    @autoreleasepool {
      Person *p = [[Person alloc] init];
      [p talk];
    }
    return 0;
  }

  #+end_example 

The differences and eccentricities of Objective C methods as compared to some other CFOL languages does not end with how the method is written. It also extends to how the method is invoked.  

Objective C has this concept of message sending and message receiving. If you want an object that contains the method to execute that method, you send it a message, and that message is the name of the method.  The code example above needs to be dissected a little bit so we can map it to our existing knowledge of classes and objects (for those coming from either C# or Java).

To create an object, we use the following syntax

  #+begin_example
  Person *p = [[Person alloc] init];
  #+end_example 

The sample snippet above is quite idiomatic, you will see lots of those codes from other people's examples and book text. It is a nested way of method calling. If we were doing in Java or C#, maybe it would look like this

  #+begin_example
  Person *p = Person.alloc().init();
  #+end_example 

Of course the snippet above is contrived, but that's how it might look if it were written by either a C# or a Java programmer. Let's rewrite our little code for creating an object so it becomes a bit more verbose. 

  #+begin_example
  Person *p;
  p = [Person alloc];
  p = [p init];
  #+end_example 

The first line declares a variable that will hold the reference to a Person object. It is of type **Person** and it is a pointer because all objects in Objective-C are of pointer types. 

Second line calls the class method *alloc* against the Person class. We are simply allocating memory for our would-be object. Notice two things in here

  1. I did not have to use the pointer operator anymore. You only use the pointer operator (when working with objects) when declaring them. That is the only time you use the asterisk. You don't use the asterisk when assigning something to the variable
  2. When we call a method against a class or object, we use the bracket notation. The receiver of the message and the message itself are enclosed on a pair of square braces

Third line of the sample code calls the *init* method of our now allocated object. You can think of the *init* method as some sort of a constructor equivalent in C# or Java. 

* Arguments

When you want methods to take on some arguments or parameters, here's the syntax on how to do it.




#+begin_example
@interface Person : NSObject
-(void) talk: (NSString*) args;
@end

@implementation Person
-(void) talk: (NSString*) args {
  NSLog(args);
}

+(id) new {
  NSLog(@"Overriding new method");
  return [[self alloc] init];
}
@end

int main(int argc, const char *argv[]) {
  Person *p;
  p = [Person alloc];
  p = [p init];
  [p talk: @"Hello there"];
}
#+end_example



* Multiple arguments 

